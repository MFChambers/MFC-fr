{"title":"Client Report - Can You Predict That?","markdown":{"yaml":{"title":"Client Report - Can You Predict That?","subtitle":"Course DS 250","author":"Maia Faith Chambers","format":{"html":{"self-contained":true,"page-layout":"full","title-block-banner":true,"toc":true,"toc-depth":3,"toc-location":"body","number-sections":false,"html-math-method":"katex","code-fold":true,"code-summary":"Show the code","code-overflow":"wrap","code-copy":"hover","code-tools":{"source":false,"toggle":true,"caption":"See code"}}},"execute":{"warning":false}},"headingText":"Imports","containsRefs":false,"markdown":"\n\n```{python}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.tree import DecisionTreeClassifier, plot_tree, export_graphviz\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, classification_report, confusion_matrix\nimport graphviz\n\n# Load dataset\nurl = \"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_ml/dwellings_ml.csv\"\ndf = pd.read_csv(url)\n\n# Prepare data\ndf['stories_str'] = df['stories'].astype(str)\ndf['numbaths_grouped'] = pd.cut(df['numbaths'], bins=[0, 1, 2, 3, 4, np.inf], labels=['<=1', '1-2', '2-3', '3-4', '4+'])\ndf['livearea_grouped'] = pd.cut(df['livearea'], bins=[0, 1000, 1500, 2000, 2500, np.inf], labels=['<1000', '1000-1500', '1500-2000', '2000-2500', '2500+'])\n\n# Add labels\ndf['before1980_label'] = df['before1980'].map({0: \"Built 1980+\", 1: \"Built Before 1980\"})\ndf['before1980_num'] = df['before1980']\n\n# Set styling\nsns.set(style=\"whitegrid\")\ncustom_palette = {\"Built 1980+\": \"#00BFC4\", \"Built Before 1980\": \"#F8766D\"}\n```\n\n## Elevator pitch\nHomes built after 1980 are more likely to have larger living areas, multiple stories, and more bathrooms. By analyzing these patterns, our model learns to predict whether a house was built before 1980 with meaningful accuracy. This insight can assist with prioritizing housing assessments and understanding development patterns.\n\n## QUESTION|TASK 1\nThese visualizations show potential relationships that a machine learning model could use to split the data. For instance, the living area (Chart 1) suggests that post-1980 homes are generally larger. Bathroom count (Chart 2) shows a shift in distribution where newer homes more often include additional bathrooms. Lastly, stories (Chart 3) indicates that single-story homes may be more common in earlier decades. These patterns can serve as helpful split points in decision trees or contribute predictive value in models like random forests or logistic regression.\n\n```{python}\n# Chart A: Grouped bathrooms\nplt.figure(figsize=(8, 5))\nsns.countplot(data=df, x='numbaths_grouped', hue='before1980_label', palette=custom_palette)\nplt.title('Grouped Number of Bathrooms vs. Year Built')\nplt.xlabel('Number of Bathrooms')\nplt.ylabel('Count')\nplt.tight_layout()\nplt.show()\n\n```\n\n```{python}\n# Chart B: Living area boxplot\nplt.figure(figsize=(8, 5))\nsns.boxplot(data=df, x='before1980_label', y='livearea', palette=custom_palette)\nplt.title('Living Area by Year Built')\nplt.xlabel('Year Built Category')\nplt.ylabel('Living Area (sqft)')\nplt.tight_layout()\nplt.show()\n\n```\n\n```{python}\n# Chart C: Proportional stories\nstory_prop = df.groupby(['stories_str', 'before1980_label']).size().reset_index(name='count')\nstory_total = story_prop.groupby('stories_str')['count'].transform('sum')\nstory_prop['proportion'] = story_prop['count'] / story_total\n\nplt.figure(figsize=(8, 5))\nsns.barplot(data=story_prop, x='stories_str', y='proportion', hue='before1980_label', palette=custom_palette)\nplt.title('Proportion of Story Count by Year Built')\nplt.xlabel('Number of Stories')\nplt.ylabel('Proportion')\nplt.tight_layout()\nplt.show()\n\n```\n\n\n\n\n## QUESTION|TASK 2\nA Decision Tree Classifier was initially selected to label homes as built before or after 1980, using the features living area (livearea), number of stories (stories), and number of bathrooms (numbaths). The model was tuned with max_depth=5 and min_samples_leaf=50 to reduce overfitting while retaining interpretability for public health staff. The resulting test accuracy was approximately 78.5%, which is a solid baseline but does not meet the 90% target.\n\nAdditional models were explored:\n\nLogistic Regression: around 78.7% accuracy; limited by its linear nature.\n\nk-Nearest Neighbors (k-NN): approximately 88% accuracy, but highly sensitive to data scaling and local outliers.\n\nRandom Forest: approximately 80.3% accuracy, with stronger generalization than a single tree, and offering ranked feature importances for interpretability.\n\n\n\n```{python}\n# Features\nfeatures = df[['livearea', 'stories', 'numbaths']].copy()\nfeatures.columns = ['Living Area', 'Stories', 'Bathrooms']\nfeatures = features.fillna(0)\n\n# Target\ntarget = df['before1980_num']\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.3, random_state=42)\n\n# Decision Tree\nclf_tree = DecisionTreeClassifier(max_depth=5, min_samples_leaf=50, criterion='entropy', random_state=42)\nclf_tree.fit(X_train, y_train)\ny_pred_tree = clf_tree.predict(X_test)\ntree_acc = accuracy_score(y_test, y_pred_tree)\nprint(f\"Decision Tree Accuracy: {tree_acc:.2%}\")\n\n\n```\n\n```{python}\n# Random Forest\nclf_rf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf_rf.fit(X_train, y_train)\ny_pred_rf = clf_rf.predict(X_test)\nrf_acc = accuracy_score(y_test, y_pred_rf)\nprint(f\"Random Forest Accuracy: {rf_acc:.2%}\")\n\n\n```\n\n```{python}\n# Logistic Regression\nclf_lr = LogisticRegression(max_iter=1000)\nclf_lr.fit(X_train, y_train)\ny_pred_lr = clf_lr.predict(X_test)\nlr_acc = accuracy_score(y_test, y_pred_lr)\nprint(f\"Logistic Regression Accuracy: {lr_acc:.2%}\")\n```\nNone of the models tested reached the 90% accuracy goal. However, Random Forest provides the best balance of interpretability, robustness, and predictive performance for a classification baseline. With further feature engineering — for example, integrating neighborhood data or temporal trends — and hyperparameter optimization (such as a grid search for tree depth and minimum leaf size), there is potential to improve model performance to approach or exceed 90% in the future.\n\nIn the current scope, the Random Forest is recommended as the best candidate for a production baseline. It is relatively easy to update if more features or additional training data become available, providing a practical foundation for ongoing improvement.\n\n## QUESTION|TASK 3\nFeature importance analysis revealed that living area (livearea) was the strongest predictor of whether a home was built before or after 1980. This makes sense because homes constructed after 1980 tend to follow modern architectural trends favoring more spacious floorplans, in contrast to smaller post-war homes built before stricter asbestos regulations.\n\nThe second most important feature was number of bathrooms (numbaths). Newer homes typically include more bathrooms to match contemporary expectations for convenience and functionality, making bathroom count a reliable indicator of more recent construction.\n\nThe number of stories (stories) feature also contributed to the classification model, although with a lower importance score. This is still valuable because single-story homes were historically more common in earlier decades, whereas modern subdivisions often include two-story designs.\n\n```{python}\n# Decision Tree importance\nimportance_tree = pd.Series(clf_tree.feature_importances_, index=features.columns).sort_values()\nplt.figure(figsize=(8, 5))\nimportance_tree.plot(kind='barh', color='lightseagreen', edgecolor='black')\nplt.title('Decision Tree Feature Importance')\nplt.xlabel('Importance Score')\nplt.tight_layout()\nplt.show()\n\n```\n\n```{python}\n# Random Forest importance\nimportance_rf = pd.Series(clf_rf.feature_importances_, index=features.columns).sort_values()\nplt.figure(figsize=(8, 5))\nimportance_rf.plot(kind='barh', color='salmon', edgecolor='black')\nplt.title('Random Forest Feature Importance')\nplt.xlabel('Importance Score')\nplt.tight_layout()\nplt.show()\n```\nThese patterns are visualized in the accompanying feature importance chart below, which shows the ranked contribution of each feature to the model. The chart confirms that living area, number of bathrooms, and number of stories are the dominant variables. Overall, these variables align with real-world domain knowledge about housing design and construction patterns and justify the model’s predictions in a way that is explainable and transparent for stakeholders.\n\nFurther improvements could include adding neighborhood-level attributes or temporal price trends to enhance predictive power.\n\n## QUESTION|TASK 4\nI evaluated the classification models using three common metrics: accuracy, precision, and recall. Each provides a different perspective on model performance:\n\nAccuracy measures the overall proportion of correct predictions across both classes. The Random Forest achieved approximately 80% accuracy, slightly higher than the Decision Tree (78%) and Logistic Regression (79%). However, accuracy alone can be misleading if the classes are imbalanced, which is why we also examine precision and recall.\n\n```{python}\nprint(\"Decision Tree Evaluation:\")\nprint(classification_report(y_test, y_pred_tree))\nprint(confusion_matrix(y_test, y_pred_tree))\n```\nPrecision measures how many predicted positives were actually correct. For example, Random Forest had a precision of 0.84 for the positive (before1980) class, meaning when it predicts a home is pre-1980, it is correct 84% of the time. Precision is especially important if a false positive (wrongly classifying a newer home as old) has public health or safety consequences, such as unnecessary asbestos remediation.\n```{python}\nprint(\"\\nRandom Forest Evaluation:\")\nprint(classification_report(y_test, y_pred_rf))\nprint(confusion_matrix(y_test, y_pred_rf))\n```\nRecall measures how many true positives were captured among all actual positives. The Random Forest achieved a recall of 0.85 for the positive class, meaning it correctly identified 85% of homes that were truly built before 1980. High recall is crucial if you want to avoid missing any potentially hazardous homes.\n```{python}\nprint(\"\\nLogistic Regression Evaluation:\")\nprint(classification_report(y_test, y_pred_lr))\nprint(confusion_matrix(y_test, y_pred_lr))\n```\nAs a balanced measure, the f1-score combines precision and recall, showing the Random Forest at 0.84 for the positive class, which is a solid compromise between missing too many cases and misclassifying safe homes.\n\nInterpretation of confusion matrices shows most of the model errors were between these borderline homes built near 1980, which is expected. For example, the Random Forest confusion matrix shows 702 false positives (newer homes classified as old) and 653 false negatives (older homes classified as new). This tradeoff is acceptable depending on whether missing a hazardous home (false negative) is worse than sending a safe home for inspection (false positive).\n\nOverall, while no model reached the 90% accuracy target, the Random Forest achieved the best balance of precision, recall, and interpretability, making it the most practical choice for a production environment. With further feature engineering or additional data, its performance could be improved.\n\n---\n\n## STRETCH QUESTION|TASK 1\n\nFor this stretch question, I tested three different algorithms to classify whether a home was built before 1980: Random Forest, Logistic Regression, and XGBoost. Each model was evaluated with a confusion matrix and either feature importance or coefficient values.\n\nAt first, all three models showed perfect or near-perfect accuracy, which seemed too good to be true. After checking, I realized the problem was that I had included yrbuilt as a feature, which is basically the answer to whether a house was built before 1980. Including it let the models “cheat” by memorizing the target, which is why the accuracy was 100%.\n\nRandom Forest’s feature importances and XGBoost’s results both confirmed this, because yrbuilt was by far the most dominant variable. Logistic Regression showed the same thing, with a huge coefficient on yrbuilt.\n\nIf yrbuilt is removed (which it should be, since you wouldn’t know it when predicting), Random Forest is still the strongest option. In earlier testing without yrbuilt, it achieved around 80% accuracy with a good balance of precision and recall. That makes it the most reliable recommendation for the client right now, with potential for improvement if more features or neighborhood data are added in the future.\n\n```{python}\n# Stretch Task 1 (corrected - no leakage)\nfrom xgboost import XGBClassifier\n\n# load from URL\nurl = \"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_ml/dwellings_ml.csv\"\njoined = pd.read_csv(url)\n\n# target\ny = joined[\"before1980\"]\n\n# drop leakage columns (yrbuilt and parcel)\nX = joined.drop(joined.filter(regex=\"before1980|yrbuilt|parcel\").columns, axis=1)\nX = X.fillna(0)\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, stratify=y, random_state=42\n)\n\ndef print_model_results(model, X_test, y_test, feature_names=None):\n    preds = model.predict(X_test)\n    cm = confusion_matrix(y_test, preds)\n    print(f\"\\n{model.__class__.__name__} Confusion Matrix:\")\n    print(pd.DataFrame(cm, index=[\"Actual 0\", \"Actual 1\"], columns=[\"Pred 0\", \"Pred 1\"]))\n    print(classification_report(y_test, preds))\n    if hasattr(model, \"feature_importances_\"):\n        fi = pd.Series(model.feature_importances_, index=feature_names)\n        print(\"Feature Importances:\")\n        print(fi.sort_values(ascending=False))\n    elif hasattr(model, \"coef_\"):\n        coefs = pd.Series(model.coef_[0], index=feature_names)\n        print(\"Coefficients:\")\n        print(coefs.sort_values(ascending=False))\n\n# 1. Random Forest\nrf = RandomForestClassifier(random_state=42)\nrf.fit(X_train, y_train)\nprint_model_results(rf, X_test, y_test, X.columns)\n\n# 2. Logistic Regression\nlr = LogisticRegression(max_iter=1000)\nlr.fit(X_train, y_train)\nprint_model_results(lr, X_test, y_test, X.columns)\n\n# 3. XGBoost\nxgb = XGBClassifier(random_state=42, use_label_encoder=False, eval_metric=\"logloss\")\nxgb.fit(X_train, y_train)\nprint_model_results(xgb, X_test, y_test, X.columns)\n\n\n```\n\n\n## STRETCH QUESTION|TASK 2\n\nAfter merging the neighborhood data with the dwellings data, I reran the same three algorithms: Random Forest, Logistic Regression, and XGBoost. All three models showed perfect or near-perfect accuracy again, with 100% classification rates, which is a strong indicator of data leakage. This happened because the yrbuilt column was still included as a feature after joining, which lets the models essentially memorize the answer.\n\nThe feature importances and coefficients confirmed this: yrbuilt was still the dominant driver in every model, overwhelming the effect of the new neighborhood variables. The added neighborhood features (like the nbhd_ variables) contributed almost nothing, showing extremely low or even zero importance scores.\n\nBecause of this, the results with the merged dataset do not actually change the recommended model. If we remove yrbuilt from the features, Random Forest would still likely perform best, similar to its ~80% accuracy from earlier runs. The neighborhood features might provide a small boost if the model is properly cleaned of leakage, but on their own they did not shift the model’s decision boundaries in a meaningful way.\n\nIn short, joining the neighborhood data did not meaningfully improve the models when yrbuilt was present, but could be helpful in the future if handled carefully and after removing data leakage.\n\n```{python}\n# Stretch Task 2 (corrected - no leakage)\n\n# get neighborhood data from URL:\nneigh_url = \"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_neighborhoods_ml/dwellings_neighborhoods_ml.csv\"\ndwell_url = \"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_ml/dwellings_ml.csv\"\n\nneigh = pd.read_csv(neigh_url)\ndwell = pd.read_csv(dwell_url)\n\n# merge\njoined2 = dwell.merge(neigh, on=\"parcel\", how=\"left\")\n\n# target\ny2 = joined2[\"before1980\"]\n\n# drop leakage columns\nX2 = joined2.drop(joined2.filter(regex=\"before1980|yrbuilt|parcel\").columns, axis=1)\nX2 = X2.fillna(0)\n\nX2_train, X2_test, y2_train, y2_test = train_test_split(\n    X2, y2, test_size=0.2, stratify=y2, random_state=42\n)\n\n# 1. Random Forest\nrf2 = RandomForestClassifier(random_state=42)\nrf2.fit(X2_train, y2_train)\nprint_model_results(rf2, X2_test, y2_test, X2.columns)\n\n# 2. Logistic Regression\nlr2 = LogisticRegression(max_iter=1000)\nlr2.fit(X2_train, y2_train)\nprint_model_results(lr2, X2_test, y2_test, X2.columns)\n\n# 3. XGBoost\nxgb2 = XGBClassifier(random_state=42, use_label_encoder=False, eval_metric=\"logloss\")\nxgb2.fit(X2_train, y2_train)\nprint_model_results(xgb2, X2_test, y2_test, X2.columns)\n\n```\n\n\n## STRETCH QUESTION|TASK 3\n\nFor this stretch question, I built a regression model to predict the year a house was built using a Random Forest Regressor. The model achieved a root mean squared error (RMSE) of about 11.6 years, meaning on average predictions were within roughly 12 years of the true build year. The median absolute error was lower, at around 3.9 years, which shows that half of the predictions were off by less than four years — a good sign that the model handles most houses reasonably well, with a few larger outliers.\n\nThe R² value was approximately 0.901, which means the model explained about 90% of the variance in the year built. Overall, this is a strong score for a regression problem with a complex target like construction year.\n\nWhile the random forest did a good job predicting year built, there is room to improve by adding more external features, such as neighborhood development data or historical zoning codes, to tighten the RMSE even further. Still, this model would provide a solid starting point for helping the client estimate missing build years when needed.\n\n```{python}\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_squared_error, r2_score, median_absolute_error\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nimport numpy as np\n\n# Load your confirmed data\ndf = pd.read_csv(\"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_ml/dwellings_ml.csv\")\n\n# set target\ny_reg = df[\"yrbuilt\"]\n\n# drop target and identifier\nX_reg = df.drop(columns=[\"yrbuilt\", \"parcel\"])\nX_reg = X_reg.fillna(0)\n\n# split\nX_train, X_test, y_train, y_test = train_test_split(\n    X_reg, y_reg, test_size=0.2, random_state=42\n)\n\n# Random Forest Regressor\nrf_reg = RandomForestRegressor(n_estimators=100, random_state=42)\nrf_reg.fit(X_train, y_train)\n\n# predict\ny_pred = rf_reg.predict(X_test)\n\n# evaluation\nrmse = np.sqrt(mean_squared_error(y_test, y_pred))   # fixes the error\nr2 = r2_score(y_test, y_pred)\nmedae = median_absolute_error(y_test, y_pred)\n\nprint(f\"RMSE: {rmse:.2f}\")\nprint(f\"R²: {r2:.3f}\")\nprint(f\"Median Absolute Error: {medae:.2f}\")\n\n# residual plot\nresiduals = y_test - y_pred\nplt.scatter(y_pred, residuals)\nplt.axhline(0, color=\"red\")\nplt.xlabel(\"Predicted Year Built\")\nplt.ylabel(\"Residuals\")\nplt.title(\"Residual Plot\")\nplt.show()\n\n# feature importances\npd.Series(rf_reg.feature_importances_, index=X_reg.columns).sort_values().plot(\n    kind=\"barh\", figsize=(10,12)\n)\nplt.title(\"Feature Importances for Year Built Regression\")\nplt.tight_layout()\nplt.show()\n```","srcMarkdownNoYaml":"\n\n```{python}\n# Imports\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.tree import DecisionTreeClassifier, plot_tree, export_graphviz\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, classification_report, confusion_matrix\nimport graphviz\n\n# Load dataset\nurl = \"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_ml/dwellings_ml.csv\"\ndf = pd.read_csv(url)\n\n# Prepare data\ndf['stories_str'] = df['stories'].astype(str)\ndf['numbaths_grouped'] = pd.cut(df['numbaths'], bins=[0, 1, 2, 3, 4, np.inf], labels=['<=1', '1-2', '2-3', '3-4', '4+'])\ndf['livearea_grouped'] = pd.cut(df['livearea'], bins=[0, 1000, 1500, 2000, 2500, np.inf], labels=['<1000', '1000-1500', '1500-2000', '2000-2500', '2500+'])\n\n# Add labels\ndf['before1980_label'] = df['before1980'].map({0: \"Built 1980+\", 1: \"Built Before 1980\"})\ndf['before1980_num'] = df['before1980']\n\n# Set styling\nsns.set(style=\"whitegrid\")\ncustom_palette = {\"Built 1980+\": \"#00BFC4\", \"Built Before 1980\": \"#F8766D\"}\n```\n\n## Elevator pitch\nHomes built after 1980 are more likely to have larger living areas, multiple stories, and more bathrooms. By analyzing these patterns, our model learns to predict whether a house was built before 1980 with meaningful accuracy. This insight can assist with prioritizing housing assessments and understanding development patterns.\n\n## QUESTION|TASK 1\nThese visualizations show potential relationships that a machine learning model could use to split the data. For instance, the living area (Chart 1) suggests that post-1980 homes are generally larger. Bathroom count (Chart 2) shows a shift in distribution where newer homes more often include additional bathrooms. Lastly, stories (Chart 3) indicates that single-story homes may be more common in earlier decades. These patterns can serve as helpful split points in decision trees or contribute predictive value in models like random forests or logistic regression.\n\n```{python}\n# Chart A: Grouped bathrooms\nplt.figure(figsize=(8, 5))\nsns.countplot(data=df, x='numbaths_grouped', hue='before1980_label', palette=custom_palette)\nplt.title('Grouped Number of Bathrooms vs. Year Built')\nplt.xlabel('Number of Bathrooms')\nplt.ylabel('Count')\nplt.tight_layout()\nplt.show()\n\n```\n\n```{python}\n# Chart B: Living area boxplot\nplt.figure(figsize=(8, 5))\nsns.boxplot(data=df, x='before1980_label', y='livearea', palette=custom_palette)\nplt.title('Living Area by Year Built')\nplt.xlabel('Year Built Category')\nplt.ylabel('Living Area (sqft)')\nplt.tight_layout()\nplt.show()\n\n```\n\n```{python}\n# Chart C: Proportional stories\nstory_prop = df.groupby(['stories_str', 'before1980_label']).size().reset_index(name='count')\nstory_total = story_prop.groupby('stories_str')['count'].transform('sum')\nstory_prop['proportion'] = story_prop['count'] / story_total\n\nplt.figure(figsize=(8, 5))\nsns.barplot(data=story_prop, x='stories_str', y='proportion', hue='before1980_label', palette=custom_palette)\nplt.title('Proportion of Story Count by Year Built')\nplt.xlabel('Number of Stories')\nplt.ylabel('Proportion')\nplt.tight_layout()\nplt.show()\n\n```\n\n\n\n\n## QUESTION|TASK 2\nA Decision Tree Classifier was initially selected to label homes as built before or after 1980, using the features living area (livearea), number of stories (stories), and number of bathrooms (numbaths). The model was tuned with max_depth=5 and min_samples_leaf=50 to reduce overfitting while retaining interpretability for public health staff. The resulting test accuracy was approximately 78.5%, which is a solid baseline but does not meet the 90% target.\n\nAdditional models were explored:\n\nLogistic Regression: around 78.7% accuracy; limited by its linear nature.\n\nk-Nearest Neighbors (k-NN): approximately 88% accuracy, but highly sensitive to data scaling and local outliers.\n\nRandom Forest: approximately 80.3% accuracy, with stronger generalization than a single tree, and offering ranked feature importances for interpretability.\n\n\n\n```{python}\n# Features\nfeatures = df[['livearea', 'stories', 'numbaths']].copy()\nfeatures.columns = ['Living Area', 'Stories', 'Bathrooms']\nfeatures = features.fillna(0)\n\n# Target\ntarget = df['before1980_num']\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.3, random_state=42)\n\n# Decision Tree\nclf_tree = DecisionTreeClassifier(max_depth=5, min_samples_leaf=50, criterion='entropy', random_state=42)\nclf_tree.fit(X_train, y_train)\ny_pred_tree = clf_tree.predict(X_test)\ntree_acc = accuracy_score(y_test, y_pred_tree)\nprint(f\"Decision Tree Accuracy: {tree_acc:.2%}\")\n\n\n```\n\n```{python}\n# Random Forest\nclf_rf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf_rf.fit(X_train, y_train)\ny_pred_rf = clf_rf.predict(X_test)\nrf_acc = accuracy_score(y_test, y_pred_rf)\nprint(f\"Random Forest Accuracy: {rf_acc:.2%}\")\n\n\n```\n\n```{python}\n# Logistic Regression\nclf_lr = LogisticRegression(max_iter=1000)\nclf_lr.fit(X_train, y_train)\ny_pred_lr = clf_lr.predict(X_test)\nlr_acc = accuracy_score(y_test, y_pred_lr)\nprint(f\"Logistic Regression Accuracy: {lr_acc:.2%}\")\n```\nNone of the models tested reached the 90% accuracy goal. However, Random Forest provides the best balance of interpretability, robustness, and predictive performance for a classification baseline. With further feature engineering — for example, integrating neighborhood data or temporal trends — and hyperparameter optimization (such as a grid search for tree depth and minimum leaf size), there is potential to improve model performance to approach or exceed 90% in the future.\n\nIn the current scope, the Random Forest is recommended as the best candidate for a production baseline. It is relatively easy to update if more features or additional training data become available, providing a practical foundation for ongoing improvement.\n\n## QUESTION|TASK 3\nFeature importance analysis revealed that living area (livearea) was the strongest predictor of whether a home was built before or after 1980. This makes sense because homes constructed after 1980 tend to follow modern architectural trends favoring more spacious floorplans, in contrast to smaller post-war homes built before stricter asbestos regulations.\n\nThe second most important feature was number of bathrooms (numbaths). Newer homes typically include more bathrooms to match contemporary expectations for convenience and functionality, making bathroom count a reliable indicator of more recent construction.\n\nThe number of stories (stories) feature also contributed to the classification model, although with a lower importance score. This is still valuable because single-story homes were historically more common in earlier decades, whereas modern subdivisions often include two-story designs.\n\n```{python}\n# Decision Tree importance\nimportance_tree = pd.Series(clf_tree.feature_importances_, index=features.columns).sort_values()\nplt.figure(figsize=(8, 5))\nimportance_tree.plot(kind='barh', color='lightseagreen', edgecolor='black')\nplt.title('Decision Tree Feature Importance')\nplt.xlabel('Importance Score')\nplt.tight_layout()\nplt.show()\n\n```\n\n```{python}\n# Random Forest importance\nimportance_rf = pd.Series(clf_rf.feature_importances_, index=features.columns).sort_values()\nplt.figure(figsize=(8, 5))\nimportance_rf.plot(kind='barh', color='salmon', edgecolor='black')\nplt.title('Random Forest Feature Importance')\nplt.xlabel('Importance Score')\nplt.tight_layout()\nplt.show()\n```\nThese patterns are visualized in the accompanying feature importance chart below, which shows the ranked contribution of each feature to the model. The chart confirms that living area, number of bathrooms, and number of stories are the dominant variables. Overall, these variables align with real-world domain knowledge about housing design and construction patterns and justify the model’s predictions in a way that is explainable and transparent for stakeholders.\n\nFurther improvements could include adding neighborhood-level attributes or temporal price trends to enhance predictive power.\n\n## QUESTION|TASK 4\nI evaluated the classification models using three common metrics: accuracy, precision, and recall. Each provides a different perspective on model performance:\n\nAccuracy measures the overall proportion of correct predictions across both classes. The Random Forest achieved approximately 80% accuracy, slightly higher than the Decision Tree (78%) and Logistic Regression (79%). However, accuracy alone can be misleading if the classes are imbalanced, which is why we also examine precision and recall.\n\n```{python}\nprint(\"Decision Tree Evaluation:\")\nprint(classification_report(y_test, y_pred_tree))\nprint(confusion_matrix(y_test, y_pred_tree))\n```\nPrecision measures how many predicted positives were actually correct. For example, Random Forest had a precision of 0.84 for the positive (before1980) class, meaning when it predicts a home is pre-1980, it is correct 84% of the time. Precision is especially important if a false positive (wrongly classifying a newer home as old) has public health or safety consequences, such as unnecessary asbestos remediation.\n```{python}\nprint(\"\\nRandom Forest Evaluation:\")\nprint(classification_report(y_test, y_pred_rf))\nprint(confusion_matrix(y_test, y_pred_rf))\n```\nRecall measures how many true positives were captured among all actual positives. The Random Forest achieved a recall of 0.85 for the positive class, meaning it correctly identified 85% of homes that were truly built before 1980. High recall is crucial if you want to avoid missing any potentially hazardous homes.\n```{python}\nprint(\"\\nLogistic Regression Evaluation:\")\nprint(classification_report(y_test, y_pred_lr))\nprint(confusion_matrix(y_test, y_pred_lr))\n```\nAs a balanced measure, the f1-score combines precision and recall, showing the Random Forest at 0.84 for the positive class, which is a solid compromise between missing too many cases and misclassifying safe homes.\n\nInterpretation of confusion matrices shows most of the model errors were between these borderline homes built near 1980, which is expected. For example, the Random Forest confusion matrix shows 702 false positives (newer homes classified as old) and 653 false negatives (older homes classified as new). This tradeoff is acceptable depending on whether missing a hazardous home (false negative) is worse than sending a safe home for inspection (false positive).\n\nOverall, while no model reached the 90% accuracy target, the Random Forest achieved the best balance of precision, recall, and interpretability, making it the most practical choice for a production environment. With further feature engineering or additional data, its performance could be improved.\n\n---\n\n## STRETCH QUESTION|TASK 1\n\nFor this stretch question, I tested three different algorithms to classify whether a home was built before 1980: Random Forest, Logistic Regression, and XGBoost. Each model was evaluated with a confusion matrix and either feature importance or coefficient values.\n\nAt first, all three models showed perfect or near-perfect accuracy, which seemed too good to be true. After checking, I realized the problem was that I had included yrbuilt as a feature, which is basically the answer to whether a house was built before 1980. Including it let the models “cheat” by memorizing the target, which is why the accuracy was 100%.\n\nRandom Forest’s feature importances and XGBoost’s results both confirmed this, because yrbuilt was by far the most dominant variable. Logistic Regression showed the same thing, with a huge coefficient on yrbuilt.\n\nIf yrbuilt is removed (which it should be, since you wouldn’t know it when predicting), Random Forest is still the strongest option. In earlier testing without yrbuilt, it achieved around 80% accuracy with a good balance of precision and recall. That makes it the most reliable recommendation for the client right now, with potential for improvement if more features or neighborhood data are added in the future.\n\n```{python}\n# Stretch Task 1 (corrected - no leakage)\nfrom xgboost import XGBClassifier\n\n# load from URL\nurl = \"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_ml/dwellings_ml.csv\"\njoined = pd.read_csv(url)\n\n# target\ny = joined[\"before1980\"]\n\n# drop leakage columns (yrbuilt and parcel)\nX = joined.drop(joined.filter(regex=\"before1980|yrbuilt|parcel\").columns, axis=1)\nX = X.fillna(0)\n\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, stratify=y, random_state=42\n)\n\ndef print_model_results(model, X_test, y_test, feature_names=None):\n    preds = model.predict(X_test)\n    cm = confusion_matrix(y_test, preds)\n    print(f\"\\n{model.__class__.__name__} Confusion Matrix:\")\n    print(pd.DataFrame(cm, index=[\"Actual 0\", \"Actual 1\"], columns=[\"Pred 0\", \"Pred 1\"]))\n    print(classification_report(y_test, preds))\n    if hasattr(model, \"feature_importances_\"):\n        fi = pd.Series(model.feature_importances_, index=feature_names)\n        print(\"Feature Importances:\")\n        print(fi.sort_values(ascending=False))\n    elif hasattr(model, \"coef_\"):\n        coefs = pd.Series(model.coef_[0], index=feature_names)\n        print(\"Coefficients:\")\n        print(coefs.sort_values(ascending=False))\n\n# 1. Random Forest\nrf = RandomForestClassifier(random_state=42)\nrf.fit(X_train, y_train)\nprint_model_results(rf, X_test, y_test, X.columns)\n\n# 2. Logistic Regression\nlr = LogisticRegression(max_iter=1000)\nlr.fit(X_train, y_train)\nprint_model_results(lr, X_test, y_test, X.columns)\n\n# 3. XGBoost\nxgb = XGBClassifier(random_state=42, use_label_encoder=False, eval_metric=\"logloss\")\nxgb.fit(X_train, y_train)\nprint_model_results(xgb, X_test, y_test, X.columns)\n\n\n```\n\n\n## STRETCH QUESTION|TASK 2\n\nAfter merging the neighborhood data with the dwellings data, I reran the same three algorithms: Random Forest, Logistic Regression, and XGBoost. All three models showed perfect or near-perfect accuracy again, with 100% classification rates, which is a strong indicator of data leakage. This happened because the yrbuilt column was still included as a feature after joining, which lets the models essentially memorize the answer.\n\nThe feature importances and coefficients confirmed this: yrbuilt was still the dominant driver in every model, overwhelming the effect of the new neighborhood variables. The added neighborhood features (like the nbhd_ variables) contributed almost nothing, showing extremely low or even zero importance scores.\n\nBecause of this, the results with the merged dataset do not actually change the recommended model. If we remove yrbuilt from the features, Random Forest would still likely perform best, similar to its ~80% accuracy from earlier runs. The neighborhood features might provide a small boost if the model is properly cleaned of leakage, but on their own they did not shift the model’s decision boundaries in a meaningful way.\n\nIn short, joining the neighborhood data did not meaningfully improve the models when yrbuilt was present, but could be helpful in the future if handled carefully and after removing data leakage.\n\n```{python}\n# Stretch Task 2 (corrected - no leakage)\n\n# get neighborhood data from URL:\nneigh_url = \"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_neighborhoods_ml/dwellings_neighborhoods_ml.csv\"\ndwell_url = \"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_ml/dwellings_ml.csv\"\n\nneigh = pd.read_csv(neigh_url)\ndwell = pd.read_csv(dwell_url)\n\n# merge\njoined2 = dwell.merge(neigh, on=\"parcel\", how=\"left\")\n\n# target\ny2 = joined2[\"before1980\"]\n\n# drop leakage columns\nX2 = joined2.drop(joined2.filter(regex=\"before1980|yrbuilt|parcel\").columns, axis=1)\nX2 = X2.fillna(0)\n\nX2_train, X2_test, y2_train, y2_test = train_test_split(\n    X2, y2, test_size=0.2, stratify=y2, random_state=42\n)\n\n# 1. Random Forest\nrf2 = RandomForestClassifier(random_state=42)\nrf2.fit(X2_train, y2_train)\nprint_model_results(rf2, X2_test, y2_test, X2.columns)\n\n# 2. Logistic Regression\nlr2 = LogisticRegression(max_iter=1000)\nlr2.fit(X2_train, y2_train)\nprint_model_results(lr2, X2_test, y2_test, X2.columns)\n\n# 3. XGBoost\nxgb2 = XGBClassifier(random_state=42, use_label_encoder=False, eval_metric=\"logloss\")\nxgb2.fit(X2_train, y2_train)\nprint_model_results(xgb2, X2_test, y2_test, X2.columns)\n\n```\n\n\n## STRETCH QUESTION|TASK 3\n\nFor this stretch question, I built a regression model to predict the year a house was built using a Random Forest Regressor. The model achieved a root mean squared error (RMSE) of about 11.6 years, meaning on average predictions were within roughly 12 years of the true build year. The median absolute error was lower, at around 3.9 years, which shows that half of the predictions were off by less than four years — a good sign that the model handles most houses reasonably well, with a few larger outliers.\n\nThe R² value was approximately 0.901, which means the model explained about 90% of the variance in the year built. Overall, this is a strong score for a regression problem with a complex target like construction year.\n\nWhile the random forest did a good job predicting year built, there is room to improve by adding more external features, such as neighborhood development data or historical zoning codes, to tighten the RMSE even further. Still, this model would provide a solid starting point for helping the client estimate missing build years when needed.\n\n```{python}\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_squared_error, r2_score, median_absolute_error\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nimport numpy as np\n\n# Load your confirmed data\ndf = pd.read_csv(\"https://raw.githubusercontent.com/byuidatascience/data4dwellings/master/data-raw/dwellings_ml/dwellings_ml.csv\")\n\n# set target\ny_reg = df[\"yrbuilt\"]\n\n# drop target and identifier\nX_reg = df.drop(columns=[\"yrbuilt\", \"parcel\"])\nX_reg = X_reg.fillna(0)\n\n# split\nX_train, X_test, y_train, y_test = train_test_split(\n    X_reg, y_reg, test_size=0.2, random_state=42\n)\n\n# Random Forest Regressor\nrf_reg = RandomForestRegressor(n_estimators=100, random_state=42)\nrf_reg.fit(X_train, y_train)\n\n# predict\ny_pred = rf_reg.predict(X_test)\n\n# evaluation\nrmse = np.sqrt(mean_squared_error(y_test, y_pred))   # fixes the error\nr2 = r2_score(y_test, y_pred)\nmedae = median_absolute_error(y_test, y_pred)\n\nprint(f\"RMSE: {rmse:.2f}\")\nprint(f\"R²: {r2:.3f}\")\nprint(f\"Median Absolute Error: {medae:.2f}\")\n\n# residual plot\nresiduals = y_test - y_pred\nplt.scatter(y_pred, residuals)\nplt.axhline(0, color=\"red\")\nplt.xlabel(\"Predicted Year Built\")\nplt.ylabel(\"Residuals\")\nplt.title(\"Residual Plot\")\nplt.show()\n\n# feature importances\npd.Series(rf_reg.feature_importances_, index=X_reg.columns).sort_values().plot(\n    kind=\"barh\", figsize=(10,12)\n)\nplt.title(\"Feature Importances for Year Built Regression\")\nplt.tight_layout()\nplt.show()\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-in-header":[{"text":"<link href=\"https://fonts.googleapis.com/css2?family=Dancing+Script&display=swap\" rel=\"stylesheet\">\n"}],"css":["../styles.css"],"toc":true,"toc-depth":3,"self-contained":true,"number-sections":false,"html-math-method":"katex","output-file":"project4.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":{"light":["flatly","theme.scss"],"dark":["darkly","theme-dark.scss"]},"code-copy":"hover","respect-user-color-scheme":true,"toc-title":"Table of Contents","toc-show":true,"toc-float":true,"toc-float-offset":100,"toc-float-width":300,"toc-float-position":"right","toc-float-breakpoint":768,"toc-float-scroll":true,"toc-float-scroll-offset":50,"toc-float-scroll-duration":300,"toc-float-scroll-easing":"ease-in-out","toc-float-scroll-target":"#toc","title":"Client Report - Can You Predict That?","subtitle":"Course DS 250","author":"Maia Faith Chambers","page-layout":"full","title-block-banner":true,"toc-location":"body","code-summary":"Show the code"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}